package ua.kiev.icyb.bio;

import java.io.IOException;
import java.io.Serializable;

/**
 * Хранилище наблюдаемых и соответствующих им скрытых последовательностей.
 * С другой стороны, хранилище можно рассматривать как набор строк 
 * {@linkplain ua.kiev.icyb.bio полных состояний}.
 * 
 * <p>Наблюдаемые и скрытые последовательности представляются в виде
 * байтовых массивов. Каждый элемент массива отвечает отдельному
 * наблюдаемому или скрытому состоянию; соответствие между целочисленным представлением
 * состояний и их смыслом в рамках предметной области определяется с помощью
 * <em>алфавитов</em> наблюдаемых и скрытых состояний. Алфавит представляет собой
 * строку, каждый символ которой должен быть уникальным и обозначать одно из состояний,
 * определяемых предметной областью. Полные состояния также могут быть представлены
 * алфавитом, однако это представление не является обязательным.
 * 
 * <p><b>Пример.</b> Для задачи распознавания фрагментов генов:
 * <ul>
 * <li>Наблюдаемых состояний четверо, они соответствуют 
 * нуклеотидам — аденину (обычно обозначается <code>A</code>), цитозину (<code>C</code>), 
 * гуанину (<code>G</code>) и тимину (<code>T</code>). Алфавит наблюдаемых состояний — строка
 * <code>"ACGT"</code>.
 * <li>Скрытых состояний двое — нуклеотиды, принадлежащие экзонам (обозначается <code>x</code>)
 * и интронам (<code>i</code>); таким образом, алфавит скрытых состояний — строка <code>"xi"</code>.
 * <li>Полных состояний восемь; полные состояния, которые соответствуют нуклеотидам в экзонах,
 * обозначаются заглавными буквами (<code>(A,x) == A</code>), а соответствующие интронам
 * — прописными (<code>(T,i) == t</code>).
 * </ul>
 * 
 * <p>Хранилище <code>set</code>, состоящее из единственной строки полных состояний <code>"ACg"</code> 
 * (нуклеотид аденин, относящийся к экзону, нуклеотид цитозин, относящийся к экзону, а также нуклеотид гуанин,
 * относящийся к интрону), удовлетворяет следующим свойствам: 
 * <pre>
 * assert(set.length() == 1);
 * assert(set.observedStates().equals("ACGT"));
 * assert(set.hiddenStates().equals("xi"));
 * assert(set.completeStates().equals("ACGTacgt"));
 * assert(Arrays.equals(set.observed(0), new byte[] { 0, 1, 2 }));
 * assert(Arrays.equals(set.hidden(0), new byte[] { 0, 0, 1 }));
 * </pre>
 */
public interface SequenceSet extends Serializable, Representable {
	
	/**
	 * Интерфейс, используемый для фильтрации набора последовательностей.
	 */
	public static interface Filter {
		
		/**
		 * Определяет, следует ли оставлять наблюдаемую и соответствующую
		 * ей скрытую последовательность в фильтрованном наборе.
		 * 
		 * @param index
		 *    индекс (с отсчетом от нуля) последовательности в исходном наборе
		 * @param observed
		 *    последовательность наблюдаемых состояний
		 * @param hidden
		 *    последовательность скрытых состояний, соответствующая наблюдаемой
		 * 
		 * @return <code>true</code>, если пара последовательностей должна остаться
		 * в фильтрованном наборе
		 */
		boolean pass(int index, byte[] observed, byte[] hidden);
	}
	
	/**
	 * Возвращает количество строк наблюдаемых (или скрытых) состояний, помещенных в хранилище.
	 *  
	 * @return количество строк в этом хранилище
	 */
	int length();
	
	/**
	 * Возвращает строку наблюдаемых состояний с заданным номером.
	 * 
	 * @param index
	 *    индекс (с отсчетом от нуля) последовательности наблюдаемых состояний 
	 *    в этом наборе
	 * @return
	 *    байтовый массив, каждый элемент которого представляет отдельное наблюдаемое состояние 
	 */
	byte[] observed(int index);
	
	/**
	 * Возвращает строку скрытых состояний с заданным номером.
	 * 
	 * @param index
	 *    индекс (с отсчетом от нуля) последовательности скрытых состояний 
	 *    в этом наборе
	 * @return
	 *    байтовый массив, каждый элемент которого представляет отдельное скрытое состояние 
	 */
	byte[] hidden(int index);
	
	/**
	 * Возвращает идентификатор для наблюдаемой строки с заданным номером.
	 * Смысл идентификатора зависит от задачи; для задач биоинформатики существуют универсальные
	 * идентификаторы генов и белков. 
	 * 
	 * @param index
	 *    индекс (с отсчетом от нуля) последовательности наблюдаемых состояний 
	 *    в этом наборе
	 * @return
	 *    строковый идентификатор последовательности; идентификатор может быть равен {@code null}
	 */
	String id(int index);
	
	/**
	 * Возвращает алфавит наблюдаемых состояний.
	 * 
	 * @return 
	 *    строка, каждый символ которой уникален и обозначает одно из наблюдаемых состояний
	 */
	String observedStates();
	
	/**
	 * Возвращает алфавит скрытых состояний.
	 * 
	 * @return 
	 *    строка, каждый символ которой уникален и обозначает одно из скрытых состояний
	 */
	String hiddenStates();
	
	/**
	 * Возвращает алфавит полных состояний. Если алфавит полных состяний не определен,
	 * вовращает {@code null}. Вначале перечисляются все состояния, скрытая часть которых
	 * равна первому скрытому состоянию, возвращаемому {@link #hiddenStates()}; порядок
	 * перечисления определяется наблюдаемой частью состояний и совпадает с их порядком
	 * в алфавите {@link #observedStates()}. Затем перечисляются все полные состояния
	 * со скрытой частью, равной
	 * <pre>
	 * this.hiddenStates().charAt(1)
	 * </pre>
	 * и так далее.
	 * 
	 * @return 
	 *    строка, каждый символ которой уникален и обозначает одно из полных состояний;
	 *    {@code null}, если алфавит полных состояний не определен
	 */
	String completeStates();
	
	/**
	 * Фильтрует набор последовательностей в соответствии с заданным индикатором вхождения.
	 * Наблюдаемые и скрытые строки в отфильтрованном наборе располагаются в том же порядке,
	 * в каком они находились в исходном наборе.
	 * 
	 * @param selector
	 *    массив булевых величин, определяющий для каждой пары наблюдаемой и соответствущей
	 *    скрытой строк в исходном наборе, будут ли они входить в отфильтрованный набор.
	 *    Длина массива не должна быть меньше размера исходного набора.
	 * @return
	 *    отфильтрованный набор последовательностей
	 */
	SequenceSet filter(boolean[] selector);
	
	/**
	 * Фильтрует набор последовательностей в соответствии с заданным фильтром.
	 * Наблюдаемые и скрытые строки в отфильтрованном наборе располагаются в том же порядке,
	 * в каком они находились в исходном наборе.
	 * 
	 * @param filter
	 *    фильтр, определяющий вхождение пар наблюдаемых и скрытых строк из исходного набора
	 *    в новый набор
	 * @return
	 *    отфильтрованный набор последовательностей
	 */
	SequenceSet filter(Filter filter);
	
	/**
	 * Сохраняет набор последовательностей в файл.
	 * 
	 * @param filename
	 *    имя файла, в который производится сохранение
	 * @throws IOException
	 *    если в процессе сохранения проихошла ошибка ввода/вывода
	 */
	void saveToFile(String filename) throws IOException;
}
