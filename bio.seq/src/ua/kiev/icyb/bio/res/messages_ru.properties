misc.file=Файл: {0}
misc.class=Объект в файле: {0}
misc.dataset=Набор данных:\n{0}\n
misc.out_file=Выходной файл: {0}
misc.in_files_n=Входные файлы: [{0} шт.]
misc.launchable_file=Запускаемый файл: {0}
misc.order=Порядок марковской цепи: {0}
misc.fitness=качество({0}) = {1}
misc.save=Сохранение данных алгоритма в файл {0}
misc.save_error=Ошибка при сохранении данных алгоритма: {0}
misc.n_processed=Обработано последовательностей: {0}
misc.mixture=Смесь распределений:\n{0}

# Environment
env.load_conf=Конфигурация загружена из файла ''{0}''
env.e_load_conf=Ошибка при загрузке конфигурации: {0}
env.debug=Уровень отладки: {0}
env.threads=Количество вычислительных потоков: {0}
env.locale=Локаль: {0}
env.encoding=Кодировка вывода: {0}

# Sequence utilities
set.tr.e_map=Некорректное отображение состояний: {0}

# Attributes
attr.ambiguous=Неоднозначность в имени поля: {0}
attr.not_supported=Неподдерживаемый тип поля: {0}

# Test cases
test.no_alg=Отсутствует алгоритм для оценки качества
test.alg=Алгоритм распознавания:\n{0}
test.train_set=Обучающая выборка:\n{0}
test.control_set=Контрольная выборка:\n{0}
test.load_error=Ошибка при чтении сохраненного алгоритма распознавания: {0}
test.skip_train=Пропускается оценка качества на обучающей выборке
test.quality=Качество:\n{0}
test.repr=Оценка качества распознавания на {0} строках ({1} обработано)
test.cv_repr={0}-кратная кросс-валидация на {1} строках ({2} обработано во всех запусках)
test.mean_train=Среднее качество на обучении:\n{0}
test.mean_ctrl=Среднее качество на контроле:\n{0}
test.fold.repr={0} - {1} строк ({2} обработано)
test.fold.train=Запуск №{0} (обучение)
test.fold.ctrl=Запуск №{0} (контроль)
test.key=Обозначения: '.'={0} обработанных посл.; '?'=пропущенная посл.; 'S'=сохранение качества

# Quality object
q.not_recognized=Пропущенных последовательностей: {0}
q.state=Качество для скрытого состояния \"{0}\":

# Recognition algorithms
alg.class=Класс: {0}
alg.chain=Марковская цепь: порядок={1}, длина зависимой части={0}
alg.threads=Число потоков вычислений: {0}
alg.base=Базовый алгоритм распознавания:\n{0}
alg.validate_cds=Проверка длины кодирующего участка, чтобы она делилась на 3: {0}
alg.approx=Тип аппроксимации: {0}, минимальный порядок цепи: {1}
alg.algs_n=Количество составляющих алгоритмов: {0}
alg.transform=Преобразование: {0}

ua.kiev.icyb.bio.alg.ThreadedAlgorithm=Класс-обертка для многопоточного распознавания \
	скрытых последовательностей
ua.kiev.icyb.bio.alg.ViterbiAlgorithm=Алгоритм распознавания на основе принципа \
	максимума правдоподобия с использованием марковской цепи в качестве вероятностной модели
ua.kiev.icyb.bio.alg.GeneViterbiAlgorithm=Алгоритм распознавания на основе принципа \
	максимума правдоподобия с использованием марковской цепи в качестве вероятностной модели \
	(модификация для распознавания фрагментов генов)
ua.kiev.icyb.bio.alg.FallthruAlgorithm=Алгоритм распознавания с аппроксимацией \
	неизвестных вероятностей
ua.kiev.icyb.bio.alg.comp.PriorityCompAlgorithm=Алгоритм распознавания, использующий \
	голосование по старшинству среди нескольких алгоритмов
ua.kiev.icyb.bio.alg.comp.SwitchAlgorithm=Композиция алгоритмов распознавания \
	с эксклюзивной компетентностью составляющих
ua.kiev.icyb.bio.alg.comp.CompSwitchAlgorithm=Композиция алгоритмов распознавания \
	с эксклюзивной компетентностью составляющих. \
	Области компетентности определяются с использованием взвешенной смеси марковских цепей
ua.kiev.icyb.bio.alg.comp.TreeSwitchAlgorithm=Композиция алгоритмов распознавания \
	с эксклюзивной компетентностью составляющих. \
	Области компетентности определяются с использованием дерева предикатов на основе \
	концентрации наблюдаемых состояний.
ua.kiev.icyb.bio.alg.TransformAlgorithm=Алгоритм, использующий преобразование последовательностей \
	для повышения качества распознавания.

# Transforms
transform.comp=Композиция нескольких преобразований.
transform.comp.parts=Составляющие:\n{0}
transform.comp.part=№{0}: {1}
transform.terminal=Добавление специального наблюдаемого состояния в конец каждой последовательности.
transform.periodic=3-периодичное отображение скрытых состояний.
transform.map=Позиционно-независимое отображение наблюдаемых и/или скрытых состояний.


# Datasets
dataset.e_states=Не совпадают алфавиты наблюдаемых и/или скрытых состояний
dataset.e_length=Не совпадают длины наблюдаемой и скрытой строк состояний
dataset.default=Невозможно прочесть данные выборки; будет использована выборка с пустыми строками
dataset.e_name=Неизвестное имя выборки: {0}
dataset.e_char=Некорректный символ последовательности: {0}
dataset.name=Название выборки/выборок: {0}
dataset.repr=Строк: {0}; наблюдаемые состояния: {1}; скрытые состояния: {2}
dataset.seq_len=Длина строк: общая - {0}, средняя - {1}
dataset.str=[{0} стр.; {1}/{2}]
dataset.est=Оценки для выборки:\n{0}

# Feature add algorithm
add.bases=Базовые фрагменты: {0}
add.order=Порядок марковской цепи при вычислении функционала качества: {0}
add.max_size=Максимальный размер множеств цепочек: {0}
add.combs=Количество сохраняемых множеств цепочек фиксированного размера: {0}
add.curr_size=Текущий размер множеств цепочек: {0}
add.size=Размер множеств цепочек: {0}
add.sets_file=Файл для сохранения отобранных множеств: {0}
add.process=Обработка {0} множеств, состоящих из {1} фрагментов...
add.trimmed=Отфильтрованные наборы цепочек: {0}
add.save_sets=Сохранение наборов цепочек в файл {0}
add.e_save_sets=Ошибка при сохранении множеств цепочек: {0}

# Genetic algorithm
gen.generations=Количество поколений: {0}
gen.crossovers=Количество скрещиваний для каждого организма: {0}
gen.mutations=Количество мутаций для каждого организма: {0}
gen.max_size=Максимальный размер поколения: {0}
gen.mutation_p=Вероятность элементарной мутации: {0}
gen.weak_cache=Использовать кэш со слабыми ссылками: {0}
gen.init_pop=Начальная популяция: {0} x {1}
gen.curr_gen=Номер текущего поколения: {0}
gen.curr_pop=Текущее поколение: {0} x {1}
gen.generation=Поколение №{0}
gen.cache=Кэш: функционал качества для {0} организмов
gen.pop_size=Размер популяции: {0}
gen.new_pop_size=Размер популяции после добавления мутаций и скрещиваний: {0}
gen.filter=Популяция фильтруется с использованием функционала качества...
gen.tasks=Вычисляется ф-л качества для {0} организмов (для {1} уже вычислено, в т.ч. {2} из кэша)
gen.save_pop=Сохранение текущей популяции в файл {0}
gen.e_save_pop=Ошибка при сохранении популяции: {0}

# Genetic algorithm for rules
gen.trim_dist=Расстояние Хэмминга для удаления близких наборов цепочек: {0}
gen.after_trim=Размер популяции после удаления близких наборов: {0}

# EM algorithm
em.max_models=Максимальное число моделей в смеси: {0}
em.min_models=Минимальное число моделей в смеси: {0}
em.min_weight=Минимальный вес модели: {0}
em.stochastic=Использовать стохастическую модификацию шага максимизации: {0}
em.iterations=Количество итераций: {0}
em.template=Шаблон для сохранения смесей: {0}
em.sel_method=Метод выбора плохих прецедентов: {0}
em.offsets=Сдвиги при выборе плохих прецедентов: по номеру = {0}, по значению = {1}
em.e_step=Шаг №{0} - ожидание
em.m_step=Шаг №{0} - максимизация
em.alignments=Распределение строк (уровень доверия = {0}): {1}
em.n_models=Количество моделей в смеси: {0}
em.weights=Веса моделей смеси: {0}
em.chain=Марковские цепи в смеси:\n{0}
em.save_comp=Сохранение смеси в файл {0}
em.save_comp_error=Ошибка при сохранении смеси: {0}
em.add=Добавлена новая компонента смеси ({0} прецедентов) с весом {1}
em.remove=Удалена компонента №{0} с весом {1}
em.bad_search=Поиск плохих прецедентов...
em.bad_found=Найдено {0} плохих прецедентов

# Tree generation algorithm
tree.rules=Конечное число правил в дереве предикатов: {0} 
tree.tree=Дерево предикатов:\n{0}
tree.order=Порядок марковской цепи при вычислении функционала качества: {0}
tree.percentages=Доли размера выборок, используемые при построении правил: {0}
tree.min_part_size=Минимальный размер части разбиения: {0}
tree.bases=Множества фрагментов, используемые в предикатах: {0}
tree.tree_file=Файл для сохранения дерева: {0}
tree.part=Рассматривается часть {0}/{1} текущего разбиения
tree.infer=Генерация предикатов
tree.rule={0}: {1} посл.
tree.small_set={0} - подмножество выборки слишком мало
tree.opt_rule=Оптимальный предикат для части №{0}: {1} с функционалом качества = {2}
tree.g_opt_rule=Глобальное оптимальное правило: {1} с функц. качества = {2}, делящее часть разбиения №{0}
tree.new_part=Создана новая часть разбиения: {0}/{1} строк ({2,number,percent}).
tree.no_rules=(нет предикатов)
tree.repr_rule={0}: Разделить часть разбиения №{1} согласно правилу {2}
tree.save_tree=Сохранение дерева предикатов в файл {0}
tree.e_save_tree=Ошибка при сохранении дерева предикатов: {0}
