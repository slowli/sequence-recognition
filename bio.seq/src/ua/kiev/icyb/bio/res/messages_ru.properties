misc.file=Файл: {0}
misc.class=Объект в файле: {0}
misc.dataset=Набор данных:\n{0}\n
misc.out_file=Выходной файл: {0}
misc.in_files_n=Входные файлы: [{0} шт.]
misc.launchable_file=Запускаемый файл: {0}
misc.order=Порядок марковской цепи: {0}
misc.fitness=качество({0}) = {1}
misc.save=Сохранение данных алгоритма в файл {0}
misc.save_error=Ошибка при сохранении данных алгоритма: {0}
misc.n_processed=Обработано последовательностей: {0}
misc.mixture=Смесь распределений:\n{0}

# Environment
env.load_conf=Конфигурация загружена из файла ''{0}''
env.e_load_conf=Ошибка при загрузке конфигурации: {0}
env.debug=Уровень отладки: {0}
env.threads=Количество вычислительных потоков: {0}
env.locale=Локаль: {0}
env.encoding=Кодировка вывода: {0}

# Sequence utilities
set.tr.e_map=Некорректное отображение состояний: {0}

# Test cases
test.no_alg=Отсутствует алгоритм для оценки качества
test.alg=Алгоритм распознавания:\n{0}
test.train_set=Обучающая выборка:\n{0}
test.control_set=Контрольная выборка:\n{0}
test.load_error=Ошибка при чтении сохраненного алгоритма распознавания: {0}
test.skip_train=Пропускается оценка качества на обучающей выборке
test.quality=Качество:\n{0}
test.repr=Оценка качества распознавания на {0} строках ({1} обработано)
test.cv_repr={0}-кратная кросс-валидация на {1} строках ({2} обработано во всех запусках)
test.mean_train=Среднее качество на обучении:\n{0}
test.mean_ctrl=Среднее качество на контроле:\n{0}
test.fold.repr={0} - {1} строк ({2} обработано)
test.fold.train=Запуск №{0} (обучение)
test.fold.ctrl=Запуск №{0} (контроль)
test.key=Обозначения: '.'={0} обработанных посл.; '?'=пропущенная посл.; 'S'=сохранение качества

# Quality object
q.not_recognized=Пропущенных последовательностей: {0}
q.state=Качество для скрытого состояния \"{0}\":

# Recognition algorithms
alg.class=Класс: {0}
alg.chain=Марковская цепь: порядок={1}, длина зависимой части={0}
alg.threads=Число потоков вычислений: {0}
alg.base=Базовый алгоритм распознавания:\n{0}
alg.validate_cds=Проверка длины кодирующего участка, чтобы она делилась на 3: {0}
alg.approx=Тип аппроксимации: {0}, минимальный порядок цепи: {1}
alg.algs_n=Количество составляющих алгоритмов: {0}

ua.kiev.icyb.bio.alg.ThreadedAlgorithm=Класс-обертка для многопоточного распознавания \
	скрытых последовательностей
ua.kiev.icyb.bio.alg.ViterbiAlgorithm=Алгоритм распознавания на основе принципа \
	максимума правдоподобия с использованием марковской цепи в качестве вероятностной модели
ua.kiev.icyb.bio.alg.GeneViterbiAlgorithm=Алгоритм распознавания на основе принципа \
	максимума правдоподобия с использованием марковской цепи в качестве вероятностной модели \
	(модификация для распознавания фрагментов генов)
ua.kiev.icyb.bio.alg.FallthruAlgorithm=Алгоритм распознавания с аппроксимацией \
	неизвестных вероятностей
ua.kiev.icyb.bio.alg.comp.PriorityCompAlgorithm=Алгоритм распознавания, использующий \
	голосование по старшинству среди нескольких алгоритмов
ua.kiev.icyb.bio.alg.comp.SwitchAlgorithm=Композиция алгоритмов распознавания \
	с эксклюзивной компетентностью составляющих
ua.kiev.icyb.bio.alg.comp.CompSwitchAlgorithm=Композиция алгоритмов распознавания \
	с эксклюзивной компетентностью составляющих. \
	Области компетентности определяются с использованием взвешенной смеси марковских цепей
ua.kiev.icyb.bio.alg.comp.TreeSwitchAlgorithm=Композиция алгоритмов распознавания \
	с эксклюзивной компетентностью составляющих. \
	Области компетентности определяются с использованием дерева предикатов на основе \
	концентрации наблюдаемых состояний

# Datasets
dataset.e_states=Не совпадают алфавиты наблюдаемых и/или скрытых состояний
dataset.e_length=Не совпадают длины наблюдаемой и скрытой строк состояний
dataset.default=Невозможно прочесть данные выборки; будет использована выборка с пустыми строками
dataset.e_name=Неизвестное имя выборки: {0}
dataset.e_char=Некорректный символ последовательности: {0}
dataset.name=Название выборки/выборок: {0}
dataset.repr=Строк: {0}; наблюдаемые состояния: {1}; скрытые состояния: {2}
dataset.seq_len=Длина строк: общая - {0}, средняя - {1}
dataset.str=[{0} стр.; {1}/{2}]
dataset.est=Оценки для выборки:\n{0}

# Feature add algorithm
add.bases=Базовые фрагменты: {0}
add.order=Порядок марковской цепи при вычислении функционала качества: {0}
add.max_size=Максимальный размер множеств цепочек: {0}
add.combs=Количество сохраняемых множеств цепочек фиксированного размера: {0}
add.curr_size=Текущий размер множеств цепочек: {0}
add.size=Размер множеств цепочек: {0}
add.sets_file=Файл для сохранения отобранных множеств: {0}
add.process=Обработка {0} множеств, состоящих из {1} фрагментов...
add.trimmed=Отфильтрованные наборы цепочек: {0}
add.save_sets=Сохранение наборов цепочек в файл {0}
add.e_save_sets=Ошибка при сохранении множеств цепочек: {0}

# Genetic algorithm
gen.generations=Количество поколений: {0}
gen.crossovers=Количество скрещиваний для каждого организма: {0}
gen.mutations=Количество мутаций для каждого организма: {0}
gen.max_size=Максимальный размер поколения: {0}
gen.mutation_p=Вероятность элементарной мутации: {0}
gen.weak_cache=Использовать кэш со слабыми ссылками: {0}
gen.init_pop=Начальная популяция: {0} x {1}
gen.curr_gen=Номер текущего поколения: {0}
gen.curr_pop=Текущее поколение: {0} x {1}
gen.generation=Поколение №{0}
gen.cache=Кэш: функционал качества для {0} организмов
gen.pop_size=Размер популяции: {0}
gen.new_pop_size=Размер популяции после добавления мутаций и скрещиваний: {0}
gen.filter=Популяция фильтруется с использованием функционала качества...
gen.tasks=Вычисляется ф-л качества для {0} организмов (для {1} уже вычислено, в т.ч. {2} из кэша)
gen.save_pop=Сохранение текущей популяции в файл {0}
gen.e_save_pop=Ошибка при сохранении популяции: {0}

# Genetic algorithm for rules
gen.trim_dist=Расстояние Хэмминга для удаления близких наборов цепочек: {0}
gen.after_trim=Размер популяции после удаления близких наборов: {0}

# EM algorithm
em.max_models=Максимальное число моделей в смеси: {0}
em.min_models=Минимальное число моделей в смеси: {0}
em.min_weight=Минимальный вес модели: {0}
em.stochastic=Использовать стохастическую модификацию шага максимизации: {0}
em.iterations=Количество итераций: {0}
em.template=Шаблон для сохранения смесей: {0}
em.sel_method=Метод выбора плохих прецедентов: {0}
em.offsets=Сдвиги при выборе плохих прецедентов: по номеру = {0}, по значению = {1}
em.e_step=Шаг №{0} - ожидание
em.m_step=Шаг №{0} - максимизация
em.alignments=Распределение строк (уровень доверия = {0}): {1}
em.n_models=Количество моделей в смеси: {0}
em.weights=Веса моделей смеси: {0}
em.chain=Марковские цепи в смеси:\n{0}
em.save_comp=Сохранение смеси в файл {0}
em.save_comp_error=Ошибка при сохранении смеси: {0}
em.add=Добавлена новая компонента смеси ({0} прецедентов) с весом {1}
em.remove=Удалена компонента №{0} с весом {1}
em.bad_search=Поиск плохих прецедентов...
em.bad_found=Найдено {0} плохих прецедентов

# Tree generation algorithm
tree.rules=Конечное число правил в дереве предикатов: {0} 
tree.tree=Дерево предикатов:\n{0}
tree.order=Порядок марковской цепи при вычислении функционала качества: {0}
tree.percentages=Доли размера выборок, используемые при построении правил: {0}
tree.min_part_size=Минимальный размер части разбиения: {0}
tree.bases=Множества фрагментов, используемые в предикатах: {0}
tree.tree_file=Файл для сохранения дерева: {0}
tree.part=Рассматривается часть {0}/{1} текущего разбиения
tree.infer=Генерация предикатов
tree.rule={0}: {1} посл.
tree.small_set={0} - подмножество выборки слишком мало
tree.opt_rule=Оптимальный предикат для части №{0}: {1} с функционалом качества = {2}
tree.g_opt_rule=Глобальное оптимальное правило: {1} с функц. качества = {2}, делящее часть разбиения №{0}
tree.new_part=Создана новая часть разбиения: {0}/{1} строк ({2,number,percent}).
tree.no_rules=(нет предикатов)
tree.repr_rule={0}: Разделить часть разбиения №{1} согласно правилу {2}
tree.save_tree=Сохранение дерева предикатов в файл {0}
tree.e_save_tree=Ошибка при сохранении дерева предикатов: {0}

# Tasks
tasks.name=Имя задания: {0}
tasks.description=Описание:\n{0}
tasks.args=Аргументы:
tasks.class_not_found=Класс, содержащий задания не найден: {0}
tasks.no_descr=(нет описания задания)
tasks.no_args=\tАргументы не принимаются
tasks.not_found=Задание не найдено: {0}

# Specific tasks
task.list=Печатает список всех доступных заданий.

task.help=Печатает помощь по заданию.
task.help.0=идентификатор задания

task.attr=Печатает значения всех полей сериализованного объекта (включая частные поля и поля \
	 суперклассов) и позволяет их изменять.
task.attr.0=имя файла с сериализованным объектом
task.attr.1=(опционально) названия полей объекта и их новые значения, разделенные \
	 знаком равенства '='. Имя поля может содержать в себе название класса, \
	 в котором поле задекларировано (для избежания неоднозначностей).

task.print=Печатает текстовое предствление сериализованного объекта.
task.print.0=файл, содержащий объект, реализующий интерфейс Representable

task.launch=Запускает алгоритм с сохраненным состоянием.
task.launch.0=файл, содержащий сохраненное состояние алгоритма

task.set.merge=Объединяет две или более выборок и сохраняет результат.
task.set.merge.0=выходной файл
task.set.merge.1=список файлов для объединения
task.set.merge.load=Загрузка выборки из файла {0}...
task.set.merge.add=Добавление выборки {0}...
task.set.merge.save=Сохранение полученной выборки...

task.set.tr=Преобразовывает наблюдаемые и/или скрытые состояния в определенной выборке.
task.set.tr.0=имя файла, содержащего исходную выборку
task.set.tr.1=имя файла для сохранения преобразованной выборки
task.set.tr.2=отображение наблюдаемых состояний выборки; должно иметь формат '<src>:<dest>', \
	 где <src> и <dest> - строки одинаковой длины, содержащие исходные и соответствующие им \
	 преобразованные состояния
task.set.tr.3=отображение скрытых состояний выборки
task.set.tr.out=Преобразованная выборка:\n{0}
task.set.tr.save=Сохранение преобразованной выборки...

task.quality=Вычисляет качество распознавания алгоритма, обученного на некоторой выборке, \
	на другой выборке.
task.quality.0=имя обучающей выборки/выборок
task.quality.1=имя контрольной выборки/выборок
task.quality.2=порядок марковской цепи, используемой в алгоритме распознавания
task.quality.3=файл, в который следует сохранять результаты кросс-валидации

task.viterbi.cv=Осуществляет кросс-валидацию для алгоритма распознавания скрытых \
	последовательностей, основанного на алгоритме Витерби.
task.viterbi.cv.0=имя используемой выборки/выборок
task.viterbi.cv.1=порядок марковской цепи, используемой в алгоритме распознавания
task.viterbi.cv.2=файл, в который следует сохранять результаты кросс-валидации

task.approx.cv=Осуществляет кросс-валидацию для алгоритма распознавания скрытых \
	последовательностей с аппроксимацией неизвестных вероятностей.
task.approx.cv.0=имя используемой выборки/выборок
task.approx.cv.1=метод аппроксимации неизвестных вероятностей (допустимые значения 'priority', \
	'mean', 'first' и 'fixed')
task.approx.cv.2=максимальный и минимальный порядок марковской цепи, используемой в \
	алгоритме распознавания, разделенные дефисом '-'
task.approx.cv.3=файл, в который следует сохранять результаты кросс-валидации

task.em.inc=Запускает EM-алгоритм для построения взвешенной смеси марковских цепей \
	с последовательным добавлением компонент.
task.em.inc.0=имя используемой выборки/выборок
task.em.inc.1=порядок марковских цепей в композиции
task.em.inc.2=конечное число вероятностных моделей в композиции
task.em.inc.3=шаблон для сохранения композиций после каждой итерации EM-алгоритма. \
	'{n}' заменяется на количество моделей в композиции; \
	'{i}' заменяется на номер итерации алгоритма
task.em.inc.4=файл для сохранения промежуточных результатов алгоритма

task.em.dec=Запускает EM-алгоритм  для построения взвешенной смеси марковских цепей \
	с последовательным удалением компонент.
task.em.dec.0=имя используемой выборки/выборок
task.em.dec.1=порядок марковских цепей в композиции
task.em.dec.2=начальное число вероятностных моделей в композиции
task.em.dec.3=конечное число вероятностных моделей в композиции
task.em.dec.4=шаблон для сохранения композиций после каждой итерации EM-алгоритма. \
	'{n}' заменяется на количество моделей в композиции; \
	'{i}' заменяется на номер итерации алгоритма
task.em.dec.5=файл для сохранения промежуточных результатов алгоритма

task.switch.cv=Осуществляет кросс-валидацию для композиции алгоритмов распознавания \
	скрытых последовтельностей с эксклюзивной компетентностью составляющих. \
	Области компетентности строятся на основе смесей марковских цепей.
task.switch.cv.0=имя используемой выборки/выборок
task.switch.cv.1=метод определения областей компетентности: 'classes', \
	чтобы использовать маркеры классов, или 'mixture' для использования смеси распределений
task.switch.cv.2=файл, определяющий области компетентности (маркеры классов, \
	разделенные пробелами или сериализованная смесь распределений, \
	в зависимости от предыдущего аргумента
task.switch.cv.3=порядок марковской цепи, используемой в алгоритме распознавания
task.switch.cv.4=файл, в который следует сохранять результаты кросс-валидации

task.features=Печатает таблицу вещественных признаков, соответствующих последовательностям \
	наблюдаемых состояний в некоторой выборке. \
	Признаки считаются как значения всех переходных вероятностей определенного порядка, \
	вычисленные для каждой из строк наблюдаемых состояний.
task.features.0=имя используемой выборки/выборок
task.features.1=имя файла, в который выводятся вычисленные свойства
task.features.2=порядок условных вероятностей (по умолчанию 4)

task.mix.classes=Выводит индекс марковской цепи из заданной композиции с максимальной \
	апостериорной вероятностью для всех строк из выборки.
task.mix.classes.0=имя используемой выборки/выборок
task.mix.classes.1=имя файла, содержащего композицию распределений
task.mix.classes.2=имя выходного файла
task.mix.classes.out=Запись индексов в файл ''{0}''...

task.mix.likelihood=Печатает среднее значение логарифмического правдоподобия для строк \
	из выборки и одной или более взвешенных смесей распределений.
task.mix.likelihood.0=имя используемой выборки/выборок
task.mix.likelihood.1=имя одного или более файлов, содержащих композиции распределений
task.mix.likelihood.p=Среднее логарифмическое правдоподобие: {0}

task.tree.genetic=Запускает генетический алгоритм для отбора множеств цепочек наблюдаемых \
	состояний, использование которых наиболее эффективно при построении областей компетентности.
task.tree.genetic.0=имя используемой выборки/выборок
task.tree.genetic.1=длина цепочек во множествах
task.tree.genetic.2=минимальное расстояние Хэмминга между множествами цепочек \
	(используется для просеивания поколений, генерируемых алгоритмом)
task.tree.genetic.3=файл для сохранения промежуточных результатов алгоритма

task.tree.add=Запускает алгоритм итеративного добавления признаков для отбора множеств \
	цепочек наблюдаемых состояний, использование которых наиболее эффективно при построении \
	областей компетентности.
task.tree.add.0=имя используемой выборки/выборок
task.tree.add.1=длина цепочек во множествах
task.tree.add.2=имя файла, в который сохраняются отобранные множества цепочек после выполнения каждой итерации
task.tree.add.3=файл для сохранения промежуточных результатов алгоритма

task.tree=Генерирует оптимальное разбиение пространства строк наблюдаемых состояний \
	 на области компетентности с использованием предикатов. Значение используемых \
	 предикатов на какой-либо строке зависит от концентрации в ней определенного \
	 множества коротких цепочек наблюдаемых состояний.
task.tree.0=имя используемой выборки/выборок
task.tree.1=файл, содержащий множества цепочек наблюдаемых состояний, \
	которые будут использоваться в предикатах в текстовом формате, \
	или длина цепочек-эталонов для того, чтобы проверять все множества \
	цепочек определенной длины
task.tree.2=количество правил в дереве
task.tree.3=файл, в который сериализуется полученное дерево предикатов
task.tree.4=файл для сохранения промежуточных результатов алгоритма

task.tree.cv=Осуществляет кросс-валидацию для композиции алгоритмов распознавания \
	скрытых последовтельностей, основанного на бинарном дереве предикатов.
task.tree.cv.0=имя используемой выборки/выборок
task.tree.cv.1=имя файла, содержащего дерево предикатов
task.tree.cv.2=порядок марковской цепи, используемой в алгоритме распознавания
task.tree.cv.3=число алгоритмов в композиции
task.tree.cv.4=файл, в который следует сохранять результаты кросс-валидации